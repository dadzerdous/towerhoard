<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Emoji Sniper V0.0.02</title>
    <style>
        body {
            margin: 0;
            background-color: #222; /* Dark grey outside the phone */
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #0f0;
            overflow: hidden;
        }

        /* The Phone Container */
        #phone-case {
            width: 375px;  /* Typical iPhone width */
            height: 667px; /* Typical iPhone height */
            background: #000;
            position: relative;
            border: 10px solid #444;
            border-radius: 30px;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            font-size: 16px;
            text-shadow: 0 0 5px #0f0;
            z-index: 20;
        }

        /* Navigation Zones */
        .nav-zone {
            position: absolute;
            top: 50%;
            width: 60px;
            height: 100px;
            transform: translateY(-50%);
            background: rgba(0, 50, 0, 0.3);
            border: 1px solid #0f0;
            color: #0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            cursor: pointer;
            z-index: 30;
            user-select: none;
            transition: background 0.1s;
        }
        .nav-zone:active { background: #0f0; color: #000; }
        
        #nav-left { left: 0; border-radius: 0 10px 10px 0; }
        #nav-right { right: 0; border-radius: 10px 0 0 10px; }

        /* Danger Indicators */
        .danger-indicator {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 20px;
            pointer-events: none;
            background: red;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 15;
            box-shadow: 0 0 20px red;
        }
        #danger-left { left: 0; }
        #danger-right { right: 0; }
        #danger-behind { 
            top: auto; bottom: 0; left: 0; right: 0; 
            width: 100%; height: 20px; 
        }

        #current-dir {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            z-index: 20;
        }
    </style>
</head>
<body>

    <div id="phone-case">
        <div id="ui-layer">
            <div>SCORE: <span id="scoreVal">0</span></div>
            <div>WAVE: <span id="waveVal">1</span></div>
            <div style="color:red">HP: <span id="hpVal">100</span>%</div>
        </div>

        <div id="current-dir">N</div>

        <div id="danger-left" class="danger-indicator"></div>
        <div id="danger-right" class="danger-indicator"></div>
        <div id="danger-behind" class="danger-indicator"></div>

        <canvas id="gameCanvas"></canvas>

        <div id="nav-left" class="nav-zone" onclick="turn(-1)">&lt;</div>
        <div id="nav-right" class="nav-zone" onclick="turn(1)">&gt;</div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const dirDisplay = document.getElementById('current-dir');

    // Directions Array: N, E, S, W
    const directions = ['N', 'E', 'S', 'W'];
    let dirIndex = 0; // Starts at N (index 0)

    let width = 375;
    let height = 667;
    canvas.width = width;
    canvas.height = height;

    // Game State
    let score = 0;
    let hp = 100;
    let wave = 1;
    let enemies = [];
    let lastTime = 0;
    let spawnTimer = 0;
    let spawnRate = 2000;

    // Input State
    let aimX = width / 2;
    let aimY = height / 2;

    // --- Input Handling ---

    // Correct mouse position for the "Phone Case"
    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: (evt.clientX - rect.left) * (canvas.width / rect.width),
            y: (evt.clientY - rect.top) * (canvas.height / rect.height)
        };
    }

    canvas.addEventListener('mousemove', (e) => {
        const pos = getMousePos(e);
        aimX = pos.x;
        aimY = pos.y;
    });

    canvas.addEventListener('mousedown', (e) => {
        shoot();
    });
    
    // Turn Logic (Relative)
    function turn(direction) {
        // direction: -1 (Left), 1 (Right)
        dirIndex += direction;
        if (dirIndex < 0) dirIndex = 3;
        if (dirIndex > 3) dirIndex = 0;
        
        dirDisplay.innerText = directions[dirIndex];
        
        // Quick visual feedback
        ctx.fillStyle = "#000";
        ctx.fillRect(0,0,width,height);
    }

    // --- Game Logic ---

    class Enemy {
        constructor() {
            this.viewIndex = Math.floor(Math.random() * 4); // 0=N, 1=E, etc
            this.view = directions[this.viewIndex];
            
            this.x = Math.random() * width;
            this.y = height / 2; 
            this.distance = 100; // 100 = far, 0 = hit
            this.speed = 0.2 + (wave * 0.05);
            
            this.type = Math.random() > 0.85 ? 'ogre' : 'zombie';
            this.symbol = this.type === 'ogre' ? 'ðŸ‘¹' : 'ðŸ§Ÿ';
            this.hp = this.type === 'ogre' ? 3 : 1;
            this.maxHp = this.hp;
        }

        update() {
            this.distance -= this.speed;
        }

        draw(ctx) {
            let scale = (100 - this.distance) / 10; 
            if (scale < 0) scale = 0;
            
            let drawY = this.y + ((100 - this.distance) * (height/300)); 
            
            ctx.font = `${25 * scale}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            ctx.fillText(this.symbol, this.x, drawY);

            // HP Bar
            if (this.hp < this.maxHp) {
                ctx.fillStyle = "red";
                ctx.fillRect(this.x - 10*scale, drawY - 20*scale, 20*scale * (this.hp/this.maxHp), 3*scale);
            }
        }
    }

    function checkIndicators() {
        let dangerL = false;
        let dangerR = false;
        let dangerB = false;

        enemies.forEach(e => {
            if (e.distance > 50) return; // Only warn if they are getting close (distance < 50)

            // Logic to find relative direction
            // 0=N, 1=E, 2=S, 3=W
            let diff = e.viewIndex - dirIndex;
            
            // Normalize diff to -1, 0, 1, 2 (or -2)
            if (diff === -3) diff = 1; // Looking W(3), Enemy N(0) -> Right
            if (diff === 3) diff = -1; // Looking N(0), Enemy W(3) -> Left
            
            if (diff === 1) dangerR = true;      // Enemy is to the right
            else if (diff === -1) dangerL = true; // Enemy is to the left
            else if (Math.abs(diff) === 2) dangerB = true; // Enemy is behind
        });

        document.getElementById('danger-left').style.opacity = dangerL ? 0.6 : 0;
        document.getElementById('danger-right').style.opacity = dangerR ? 0.6 : 0;
        document.getElementById('danger-behind').style.opacity = dangerB ? 0.6 : 0;
    }

    function shoot() {
        // Flash
        ctx.fillStyle = "rgba(255, 255, 200, 0.5)";
        ctx.fillRect(0, 0, width, height);

        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            
            // Must be in current view
            if (e.viewIndex !== dirIndex) continue;

            let scale = (100 - e.distance) / 10;
            let drawY = e.y + ((100 - e.distance) * (height/300));
            let size = 25 * scale; 
            
            // Hitbox calculation
            let dist = Math.hypot(e.x - aimX, drawY - aimY);

            if (dist < size) {
                e.hp--;
                if (e.hp <= 0) {
                    enemies.splice(i, 1);
                    score += 10;
                    document.getElementById('scoreVal').innerText = score;
                }
                break; 
            }
        }
    }

    function gameLoop(timestamp) {
        let dt = timestamp - lastTime;
        lastTime = timestamp;

        // Dark background with slight green tint
        ctx.fillStyle = "#051105";
        ctx.fillRect(0, 0, width, height);

        // Horizon Line
        ctx.strokeStyle = '#004400';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, height/2); ctx.lineTo(width, height/2);
        ctx.stroke();

        // Spawn
        spawnTimer += dt;
        if (spawnTimer > spawnRate) {
            enemies.push(new Enemy());
            spawnTimer = 0;
            if (spawnRate > 600) spawnRate -= 20;
        }

        // Draw & Update Enemies
        enemies.sort((a, b) => b.distance - a.distance); // Draw far enemies first
        
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            e.update();

            if (e.distance <= 0) {
                hp -= 10;
                enemies.splice(i, 1);
                document.getElementById('hpVal').innerText = hp;
                if (hp <= 0) {
                    alert("GAME OVER! Score: " + score);
                    location.reload();
                }
            }

            if (e.viewIndex === dirIndex) {
                e.draw(ctx);
            }
        }

        checkIndicators();

        // Scope Vignette
        let gradient = ctx.createRadialGradient(aimX, aimY, 100, aimX, aimY, 300);
        gradient.addColorStop(0, "transparent");
        gradient.addColorStop(1, "black");
        ctx.fillStyle = gradient;
        ctx.fillRect(0,0,width,height);

        // Crosshair
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(aimX, aimY, 20, 0, Math.PI*2);
        ctx.moveTo(aimX, aimY-30); ctx.lineTo(aimX, aimY+30);
        ctx.moveTo(aimX-30, aimY); ctx.lineTo(aimX+30, aimY);
        ctx.stroke();

        requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
