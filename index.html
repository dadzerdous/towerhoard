<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Emoji Sniper Defense</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            color: #0f0; /* Retro terminal green */
            touch-action: none; /* Disables double-tap zoom on mobile */
        }
        #gameCanvas {
            display: block;
            cursor: none; /* Hide default cursor for immersion */
        }
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            font-size: 18px;
            text-shadow: 0 0 5px #0f0;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .dir-btn {
            background: #003300;
            border: 2px solid #0f0;
            color: #0f0;
            padding: 15px 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
        }
        .dir-btn.active {
            background: #0f0;
            color: #000;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            border: 2px solid red;
            border-radius: 50%;
            z-index: 10;
        }
        /* Mobile specific message */
        #mobile-hint {
            display: none; 
            position: absolute; 
            top: 50%; width: 100%; 
            text-align: center; color: #555;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div>SCORE: <span id="scoreVal">0</span></div>
        <div>WAVE: <span id="waveVal">1</span></div>
        <div>HP: <span id="hpVal">100</span>%</div>
        <div id="msg" style="color: yellow; margin-top:10px;"></div>
    </div>

    <div id="crosshair"></div>

    <canvas id="gameCanvas"></canvas>

    <div id="controls">
        <button class="dir-btn" onclick="changeView('N')" id="btn-N">N</button>
        <button class="dir-btn" onclick="changeView('E')" id="btn-E">E</button>
        <button class="dir-btn" onclick="changeView('S')" id="btn-S">S</button>
        <button class="dir-btn" onclick="changeView('W')" id="btn-W">W</button>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const crosshairEl = document.getElementById('crosshair');

    // Game State
    let width, height;
    let currentView = 'N'; // N, E, S, W
    let score = 0;
    let hp = 100;
    let wave = 1;
    let enemies = [];
    let lastTime = 0;
    let spawnTimer = 0;
    let spawnRate = 2000; // ms

    // Mouse/Touch Position
    let aimX = 0;
    let aimY = 0;

    // View Colors to help distinguish directions subtly
    const skyColors = {
        'N': '#050505',
        'E': '#050005',
        'S': '#000505',
        'W': '#050500'
    };

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        aimX = width / 2;
        aimY = height / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    // Input Handling
    canvas.addEventListener('mousemove', (e) => {
        aimX = e.clientX;
        aimY = e.clientY;
        updateCrosshair();
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        aimX = e.touches[0].clientX;
        aimY = e.touches[0].clientY;
        updateCrosshair();
    }, {passive: false});

    canvas.addEventListener('mousedown', shoot);
    canvas.addEventListener('touchstart', (e) => { shoot(); }, {passive: false});

    function updateCrosshair() {
        crosshairEl.style.left = aimX + 'px';
        crosshairEl.style.top = aimY + 'px';
    }

    function changeView(dir) {
        currentView = dir;
        // Update UI
        ['N','E','S','W'].forEach(d => {
            document.getElementById('btn-'+d).classList.remove('active');
        });
        document.getElementById('btn-'+dir).classList.add('active');
        showMessage(`View: ${dir}`);
    }

    // --- Game Logic ---

    class Enemy {
        constructor() {
            this.view = ['N','E','S','W'][Math.floor(Math.random() * 4)];
            // Random position on the "horizon"
            this.x = Math.random() * width;
            this.y = height / 2; // Horizon line
            
            // "Z" represents distance. 100 is far, 0 is close (hit).
            this.distance = 100; 
            this.speed = 0.3 + (wave * 0.05);
            
            this.type = Math.random() > 0.8 ? 'ogre' : 'zombie';
            this.symbol = this.type === 'ogre' ? 'ðŸ‘¹' : 'ðŸ§Ÿ';
            this.hp = this.type === 'ogre' ? 3 : 1;
            this.maxHp = this.hp;
        }

        update() {
            this.distance -= this.speed;
        }

        draw(ctx) {
            // Perspective math
            // Scale grows as distance shrinks
            let scale = (100 - this.distance) / 10; 
            if (scale < 0) scale = 0;
            
            // Y position moves down slightly as they get closer (fake 3D floor)
            let drawY = this.y + ((100 - this.distance) * (height/200)); 
            
            ctx.font = `${20 * scale}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // Draw Enemy
            ctx.fillStyle = "white";
            ctx.fillText(this.symbol, this.x, drawY);

            // Draw HP bar if aiming at it or damaged
            if (this.hp < this.maxHp || scale > 5) {
                ctx.fillStyle = "red";
                ctx.fillRect(this.x - 10*scale, drawY - 15*scale, 20*scale * (this.hp/this.maxHp), 2*scale);
            }
        }
    }

    function shoot() {
        // Flash effect
        ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
        ctx.fillRect(0, 0, width, height);

        // Hit Detection
        // We iterate backwards so we hit the closest enemies (rendered last) first
        let hit = false;
        
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            
            // Can only shoot enemies in current view
            if (e.view !== currentView) continue;

            // Simple collision: check distance between aim and enemy center
            // We need to calculate where the enemy actually is on screen
            let scale = (100 - e.distance) / 10;
            let drawY = e.y + ((100 - e.distance) * (height/200));
            
            let size = 20 * scale; 
            let distToClick = Math.hypot(e.x - aimX, drawY - aimY);

            // Hitbox size depends on scale (closer = easier to hit)
            if (distToClick < size) {
                e.hp--;
                hit = true;
                if (e.hp <= 0) {
                    enemies.splice(i, 1);
                    score += (e.type === 'ogre' ? 50 : 10);
                    updateUI();
                }
                break; // Bullets don't penetrate (yet)
            }
        }
    }

    function updateUI() {
        document.getElementById('scoreVal').innerText = score;
        document.getElementById('hpVal').innerText = hp;
        document.getElementById('waveVal').innerText = wave;
    }

    function showMessage(text) {
        const el = document.getElementById('msg');
        el.innerText = text;
        setTimeout(() => { if(el.innerText === text) el.innerText = ''; }, 2000);
    }

    // --- Main Loop ---

    function gameLoop(timestamp) {
        let dt = timestamp - lastTime;
        lastTime = timestamp;

        // Background / Night Vision Tint
        ctx.fillStyle = skyColors[currentView];
        ctx.fillRect(0, 0, width, height);
        
        // Grid lines for "Sniper Scope" feel
        ctx.strokeStyle = '#003300';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, height/2); ctx.lineTo(width, height/2); // Horizon
        ctx.stroke();

        // Spawn Logic
        spawnTimer += dt;
        if (spawnTimer > spawnRate) {
            enemies.push(new Enemy());
            spawnTimer = 0;
            // Ramp up difficulty slowly
            if (spawnRate > 500) spawnRate -= 10; 
        }

        // Process Enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            e.update();

            // Game Over / Damage Logic
            if (e.distance <= 0) {
                hp -= 10;
                enemies.splice(i, 1);
                updateUI();
                showMessage("TOOK DAMAGE!");
                // Screen shake effect could go here
                if (hp <= 0) {
                    alert("GAME OVER! Score: " + score);
                    location.reload();
                }
            }
            
            // Draw ONLY if in current view
            if (e.view === currentView) {
                e.draw(ctx);
            } else {
                // Hint System: Show arrow if enemy is close in another view
                if (e.distance < 30) {
                    // Logic to show indicators could go here
                }
            }
        }

        // Scope Overlay (Black circle mask)
        // To make it feel like a scope, we darken everything OUTSIDE a radius
        ctx.globalCompositeOperation = 'destination-in';
        ctx.beginPath();
        ctx.arc(aimX, aimY, 250, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0,0,0,1)";
        ctx.fill();
        
        // Reset composite operation
        ctx.globalCompositeOperation = 'source-over';
        
        // Draw Scope lines
        ctx.strokeStyle = "#0f0";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(aimX, aimY, 250, 0, Math.PI*2); // Outer ring
        ctx.stroke();
        
        requestAnimationFrame(gameLoop);
    }

    // Init
    document.getElementById('btn-N').classList.add('active');
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
